{"title":"自定义Yeoman生成器","slug":"自定义Yeoman生成器","date":"2016-04-02T23:51:23.000Z","updated":"2022-01-20T04:12:09.029Z","comments":true,"path":"api/articles/自定义Yeoman生成器.json","excerpt":"年前整理的一篇文章：自定义Yeoman生成器 —— JSCON-简时空, 因为原链接的可读性太差，就通过MarkDown语法重新整理了下，根据该文章 构建了自己的yeoman generator ：generator-kmapp, 只是简单的实现了模板复制，安装bower , 和npm 依赖模块的功能，这样实现一键构建业务中的开发环境：本地服务器，自动刷新，less自动编译，接口转发等功能。","covers":null,"content":"<p>年前整理的一篇文章：<a href=\"http://www.jscon.co/coding/frontend/yeoman_generator.html\">自定义Yeoman生成器 —— JSCON-简时空</a>, 因为原链接的可读性太差，就通过MarkDown语法重新整理了下，根据该文章 构建了自己的yeoman generator ：<a href=\"https://github.com/sumaolin/generator-kmapp\">generator-kmapp</a>, 只是简单的实现了模板复制，安装bower , 和npm 依赖模块的功能，这样实现一键构建业务中的开发环境：本地服务器，自动刷新，less自动编译，接口转发等功能。</p>\n<span id=\"more\"></span>\n\n\n<h2 id=\"1-Getting-Started\"><a href=\"#1-Getting-Started\" class=\"headerlink\" title=\"1 Getting Started\"></a>1 Getting Started</h2><h3 id=\"1-1、设置Node模块\"><a href=\"#1-1、设置Node模块\" class=\"headerlink\" title=\"1.1、设置Node模块\"></a>1.1、设置Node模块</h3><p>Yeoman提供了generator-generator方便快速编写自己的生成器。</p>\n<blockquote>\n<p>安装: npm install -g generator-generator</p>\n</blockquote>\n<blockquote>\n<p>运行: yo generator</p>\n</blockquote>\n<ul>\n<li>创建一个名为generator-name的文件夹（name为你的生成器名）;【important】</li>\n<li>创建package.json文件，这是NodeJS模块的“信息图”，可以手动或者使用命令npm init生成</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;generator-name&quot;</span>,<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.1.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span>,<br>  <span class=\"hljs-string\">&quot;keywords&quot;</span>: [<span class=\"hljs-string\">&quot;yeoman-generator&quot;</span>],<br>  <span class=\"hljs-string\">&quot;dependencies&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;yeoman-generator&quot;</span>: <span class=\"hljs-string\">&quot;^0.17.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>name属性必须要有generator-前缀；keywords属性必须包含yeoman-generator，务必确保是最新的，可运行命令npm install –save yeoman-generator完成更新/安装</p>\n</blockquote>\n<h3 id=\"1-2、文件树结构\"><a href=\"#1-2、文件树结构\" class=\"headerlink\" title=\"1.2、文件树结构\"></a>1.2、文件树结构</h3><ol>\n<li>当调用yo name命令时，默认调用的是app生成器，对于的逻辑放置在app/文件夹下</li>\n<li>当调用yo name:subcommand命令时，必须要有对于的subcommand/文件夹</li>\n</ol>\n<p>如果文件结构如下，则该生成器暴露yo name和yo name:router两个命令</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">├───package.json<br>├───app/<br>│   └───index.js<br>└───router/<br>    └───index.js<br></code></pre></td></tr></table></figure>\n\n<p>如果你不想把所有代码都放在根目录下，Yeoman提供了另外的一种方式：可以放在generators/目录下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">├───package.json<br>└───generators/<br>    ├───app/<br>    │   └───index.js<br>    └───router/<br>        └───index.js<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-3、继承generator\"><a href=\"#1-3、继承generator\" class=\"headerlink\" title=\"1.3、继承generator\"></a>1.3、继承generator</h3><p>结构写好了，需要开始写实际的逻辑代码。Yeoman提供了基础生成器供你继承，这些基础生成器提供了很多方便的方法供你调用。基本写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> generators = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;yeoman-generator&#x27;</span>);<br><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend();<br></code></pre></td></tr></table></figure>\n\n<p>如果你的生成器需要name参数（比如yo name:router foo中的foo），想将它赋给this.name的话：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> generators = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;yeoman-generator&#x27;</span>);<br><span class=\"hljs-built_in\">module</span>.exports = generators.NamedBase.extend();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>上面两种方式都能用于创建app生成器或者子生成器，Base多用于app生成器，NamedBase多用于需要指定文件名的子生成器</p>\n</blockquote>\n<h3 id=\"1-4、重写构造函数\"><a href=\"#1-4、重写构造函数\" class=\"headerlink\" title=\"1.4、重写构造函数\"></a>1.4、重写构造函数</h3><p>有些方法只能在constructor方法中调用，常用于状态控制；可以传入构造函数重写默认的构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-comment\">// The name `constructor` is important here</span><br>  <span class=\"hljs-attr\">constructor</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// Calling the super constructor is important so our generator is correctly set up</span><br>    generators.Base.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br><br>    <span class=\"hljs-comment\">// Next, add your custom code</span><br>    <span class=\"hljs-built_in\">this</span>.option(<span class=\"hljs-string\">&#x27;coffee&#x27;</span>); <span class=\"hljs-comment\">// This method adds support for a `--coffee` flag</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"1-5、添加方法\"><a href=\"#1-5、添加方法\" class=\"headerlink\" title=\"1.5、添加方法\"></a>1.5、添加方法</h3><p>一般给原型添加的方法是按顺序执行的，不过后面我们会看到一些特殊的方法会触发不同的执行顺序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">method1</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;method 1 just ran&#x27;</span>);<br>  &#125;,<br>  <span class=\"hljs-attr\">method2</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;method 2 just ran&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"1-6、运行生成器\"><a href=\"#1-6、运行生成器\" class=\"headerlink\" title=\"1.6、运行生成器\"></a>1.6、运行生成器</h3><p>到了这一步，你已经拥有一个可以运行的生成器了。下一步就是检验生成器是否按自己的逻辑运行。由于是在本地开发生成器，在全局npm模块中并不存在，需要手动链接。进入generator-name/文件夹，运行：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">npm</span> link<br></code></pre></td></tr></table></figure>\n<p>这将自动安装工程依赖包，同时将本地文件链接进全局模块；运行完毕之后，你就可以调用yo name并看到之前定义的console.log信息。</p>\n<p>至此，恭喜你完成了简单的生成器！</p>\n<h3 id=\"1-7、找到工程根目录\"><a href=\"#1-7、找到工程根目录\" class=\"headerlink\" title=\"1.7、找到工程根目录\"></a>1.7、找到工程根目录</h3><p>当运行一个生成器，Yeoman将计算当前的文件目录信息。最为关键的是，Yeoman将.yo-rc.json所在的目录作为工程的根目录，之后Yeoman将当前文件目录跳转到根目录下运行请求的生成器。这个.yo-rc.json文件是由Storage模块创建的，在生成器内部调用this.config.save()方法就会创建它。所以，如果你发现你的生成器不是在你当前工作目录下运行，请确保。yo-rc.json不存在你目录的其他层级中</p>\n<h2 id=\"2、运行上下文\"><a href=\"#2、运行上下文\" class=\"headerlink\" title=\"2、运行上下文\"></a>2、运行上下文</h2><h3 id=\"2-1、静态方法都是Action\"><a href=\"#2-1、静态方法都是Action\" class=\"headerlink\" title=\"2.1、静态方法都是Action\"></a>2.1、静态方法都是Action</h3><p>如果一个函数直接作为生成器的原型（prototype）的属性，则会当做action自动（按顺序）执行。如何声明不会自动执行的辅助函数以及私有函数呢？有三种方法：</p>\n<ol>\n<li>给方法前面添加前缀（例如：_method）</li>\n<li>使用实例函数声明（this.mehtod）<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.helperMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;won\\&#x27;t be called automatically&#x27;</span>);<br>    &#125;;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li>\n<li>继承自父类生成器<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> MyBase = generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">helper</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;won\\&#x27;t be called automatically&#x27;</span>);<br>  &#125;<br>&#125;);<br><br><span class=\"hljs-built_in\">module</span>.exports = MyBase.extend(&#123;<br>  <span class=\"hljs-attr\">exec</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.helper();<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-2、运行顺序\"><a href=\"#2-2、运行顺序\" class=\"headerlink\" title=\"2.2、运行顺序\"></a>2.2、运行顺序</h3>Yeoman是按照优先级顺序依次执行所定义的方法。当你定义的函数名字是Yeoman定义的优先级函数名时，会自动将该函数列入到所在优先级队列中，否则就会列入到default优先层级队列中。</li>\n</ol>\n<p>依次执行的方法名称为：</p>\n<ol>\n<li><strong>initializing</strong> - 你的初始化方法（检测当前目录状态，获取配置等）</li>\n<li><strong>prompting</strong> – 给用户展示选项提示（调用this.prompt()）</li>\n<li><strong>configuring</strong> – 保存用户配置项，同时配置工程（创建.editorconfig文件或者其他metadata文件）</li>\n<li><strong>default</strong></li>\n<li><strong>writing</strong> – 用于生成和生成器相关的文件（比如routes,controllers等）</li>\n<li><strong>conflicts</strong> – 用于处理冲突异常（内部使用）</li>\n<li><strong>install</strong> – 用于安装相关库 (npm, bower)</li>\n<li><strong>end</strong> – 最后调用，常用于清理、道别等</li>\n</ol>\n<h2 id=\"3、UI\"><a href=\"#3、UI\" class=\"headerlink\" title=\"3、UI\"></a>3、UI</h2><p>Yeoman默认是跑在终端的，但不限于终端。因此记住，不要使用console.log()或者process.stdout.write()向用户反馈信息，应当使用generator.log方法。</p>\n<h3 id=\"3-1、提示框\"><a href=\"#3-1、提示框\" class=\"headerlink\" title=\"3.1、提示框\"></a>3.1、提示框</h3><p>Yeoman中最为主要的UI交互就是提示框，由Inquirer.js组件提供。使用下列方式调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">prompting</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> done = <span class=\"hljs-built_in\">this</span>.async();<br>    <span class=\"hljs-built_in\">this</span>.prompt(&#123;<br>      <span class=\"hljs-attr\">type</span>    : <span class=\"hljs-string\">&#x27;input&#x27;</span>,<br>      <span class=\"hljs-attr\">name</span>    : <span class=\"hljs-string\">&#x27;name&#x27;</span>,<br>      <span class=\"hljs-attr\">message</span> : <span class=\"hljs-string\">&#x27;Your project name&#x27;</span>,<br>      <span class=\"hljs-attr\">default</span> : <span class=\"hljs-built_in\">this</span>.appname <span class=\"hljs-comment\">// Default to current folder name</span><br>    &#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">answers</span>) </span>&#123;<br>      <span class=\"hljs-built_in\">this</span>.log(answers.name);<br>      done();<br>    &#125;.bind(<span class=\"hljs-built_in\">this</span>));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>这里我们使用promoting的优先层级 。由于咨询用户是一个异步的过程，会卡住命令逻辑的运行，所以需要调用yo的异步方法：<code>var cb = this.async();</code></p>\n</blockquote>\n<h3 id=\"3-2、记住用户偏好\"><a href=\"#3-2、记住用户偏好\" class=\"headerlink\" title=\"3.2、记住用户偏好\"></a>3.2、记住用户偏好</h3><p>当用户运行你的生成器时，很多时候会输入相同的答案；Yeoman扩展了Inquirer.js的API，额外增加了store的属性表示用户可以将之前填写过的答案作为后续的默认答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">this</span>.prompt(&#123;<br>  <span class=\"hljs-attr\">type</span>    : <span class=\"hljs-string\">&#x27;input&#x27;</span>,<br>  <span class=\"hljs-attr\">name</span>    : <span class=\"hljs-string\">&#x27;username&#x27;</span>,<br>  <span class=\"hljs-attr\">message</span> : <span class=\"hljs-string\">&#x27;What\\&#x27;s your Github username&#x27;</span>,<br>  <span class=\"hljs-attr\">store</span>   : <span class=\"hljs-literal\">true</span><br>&#125;, callback);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>提供默认答案时，程序会强制用户输入</p>\n</blockquote>\n<h3 id=\"3-3、命令行参数\"><a href=\"#3-3、命令行参数\" class=\"headerlink\" title=\"3.3、命令行参数\"></a>3.3、命令行参数</h3><p>可以直接像在命令中传入参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">yo webapp my-project<br></code></pre></td></tr></table></figure>\n<p>在这里，my-project作为第一个参数。为了提示系统我们期望用户传入参数，需要调用generator.argument()方法，该方法接受name作为参数，以及额外的限制条件。</p>\n<blockquote>\n<p> 该argument方法必须在构造器中调用。这些条件是（key/value型）：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;desc&#x27;</span>： <span class=\"hljs-comment\">//Description for the argument</span><br><span class=\"hljs-string\">&#x27;required&#x27;</span>： <span class=\"hljs-comment\">// Boolean whether it is required</span><br><span class=\"hljs-string\">&#x27;optional&#x27;</span>： <span class=\"hljs-comment\">//Boolean whether it is optional</span><br><span class=\"hljs-string\">&#x27;type&#x27;</span>： <span class=\"hljs-comment\">// String, Number, Array, or Object</span><br><span class=\"hljs-string\">&#x27;defaults&#x27;</span>： <span class=\"hljs-comment\">//Default value for this argument</span><br><span class=\"hljs-string\">&#x27;banner&#x27;</span>:  <span class=\"hljs-comment\">//String to show on usage notes (this one is provided by default)</span><br></code></pre></td></tr></table></figure>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-comment\">// note: arguments and options should be defined in the constructor.</span><br>  <span class=\"hljs-attr\">constructor</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    generators.Base.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br><br>    <span class=\"hljs-comment\">// This makes `appname` a required argument.</span><br>    <span class=\"hljs-built_in\">this</span>.argument(<span class=\"hljs-string\">&#x27;appname&#x27;</span>, &#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>, <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span> &#125;);<br>    <span class=\"hljs-comment\">// And you can then access it later on this way; e.g. CamelCased</span><br>    <span class=\"hljs-built_in\">this</span>.appname = <span class=\"hljs-built_in\">this</span>._.camelize(<span class=\"hljs-built_in\">this</span>.appname);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-4、选项\"><a href=\"#3-4、选项\" class=\"headerlink\" title=\"3.4、选项\"></a>3.4、选项</h3><p>选项看上去像参数，不过它前面多了两短横杠（flags）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">yo webapp --coffee<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>使用generator.option()方法获取选项值，该方法也有可选的限制属性（key/value型）：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;desc&#x27;</span>： <span class=\"hljs-comment\">// Description for the option</span><br><span class=\"hljs-string\">&#x27;type&#x27;</span> ：<span class=\"hljs-comment\">// Either Boolean, String or Number</span><br><span class=\"hljs-string\">&#x27;defaults&#x27;</span>： <span class=\"hljs-comment\">// Default value</span><br><span class=\"hljs-string\">&#x27;hide&#x27;</span>： <span class=\"hljs-comment\">//Boolean whether to hide from help</span><br></code></pre></td></tr></table></figure>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-comment\">// note: arguments and options should be defined in the constructor.</span><br>  <span class=\"hljs-attr\">constructor</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    generators.Base.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br><br>    <span class=\"hljs-comment\">// This method adds support for a `--coffee` flag</span><br>    <span class=\"hljs-built_in\">this</span>.option(<span class=\"hljs-string\">&#x27;coffee&#x27;</span>);<br>    <span class=\"hljs-comment\">// And you can then access it later on this way; e.g.</span><br>    <span class=\"hljs-built_in\">this</span>.scriptSuffix = (<span class=\"hljs-built_in\">this</span>.options.coffee ? <span class=\"hljs-string\">&quot;.coffee&quot;</span>: <span class=\"hljs-string\">&quot;.js&quot;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4、处理依赖\"><a href=\"#4、处理依赖\" class=\"headerlink\" title=\"4、处理依赖\"></a>4、处理依赖</h2><p>在运行生成器时，经常会伴随着npm和bower命令去安装依赖文件，Yeoman已经将这些功能抽离出来方便用户使用</p>\n<h3 id=\"4-1、npm\"><a href=\"#4-1、npm\" class=\"headerlink\" title=\"4.1、npm\"></a>4.1、npm</h3><p>使用generator.npmInstall()运行npm安装命令，无论你调用多少次，Yeoman会确保该命令只执行一次</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">installingLodash</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> done = <span class=\"hljs-built_in\">this</span>.async();<br>    <span class=\"hljs-built_in\">this</span>.npmInstall([<span class=\"hljs-string\">&#x27;lodash&#x27;</span>], &#123; <span class=\"hljs-string\">&#x27;saveDev&#x27;</span>: <span class=\"hljs-literal\">true</span> &#125;, done);<br>  &#125;<br>&#125;):<br></code></pre></td></tr></table></figure>\n<p>上面的代码等价于命令行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">npm install lodash --save-dev<br></code></pre></td></tr></table></figure>\n<h3 id=\"4-2、bower\"><a href=\"#4-2、bower\" class=\"headerlink\" title=\"4.2、bower\"></a>4.2、bower</h3><p>使用generator.bowerInstall()运行bower安装命令，无论你调用多少次，Yeoman会确保该命令只执行一次</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.spawnCommand(<span class=\"hljs-string\">&#x27;composer&#x27;</span>, [<span class=\"hljs-string\">&#x27;install&#x27;</span>]);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>记得在end队列中调用spawnCommand命令,否则用户没有耐心等那么久的。</p>\n</blockquote>\n<h2 id=\"5、文件系统\"><a href=\"#5、文件系统\" class=\"headerlink\" title=\"5、文件系统\"></a>5、文件系统</h2><p>方便文件流的输入输出，Yeoman使用两种位置环境： <strong>destination context</strong>  和 <strong>template context</strong></p>\n<h3 id=\"5-1、destination-contex-目标位置上下文\"><a href=\"#5-1、destination-contex-目标位置上下文\" class=\"headerlink\" title=\"5.1、destination contex 目标位置上下文\"></a>5.1、destination contex 目标位置上下文</h3><p>destination context 目标位置上下文，这里的“目标”是指你想架构应用的位置。这个位置要么是当前文件夹，要么就是文件.yo-rc.json所在的父文件夹位置；</p>\n<blockquote>\n<p>该.yo-rc.json文件确保所有的终端用户都以同样的方式方法生成器所在的子文件（夹）</p>\n</blockquote>\n<p>使用<code>generator.destinationRoot()</code>获取目标位置上下文；也可以手动传参重新设置，当然没有人愿意那么做的；用<code>generator.destinationPath(&#39;sub/path&#39;)</code>拼接所需要的路径字符串。示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Given destination root is ~/projects</span><br>generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">paths</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.destinationRoot();<br>    <span class=\"hljs-comment\">// returns &#x27;~/projects&#x27;</span><br><br>    <span class=\"hljs-built_in\">this</span>.destinationPath(<span class=\"hljs-string\">&#x27;index.js&#x27;</span>);<br>    <span class=\"hljs-comment\">// returns &#x27;~/projects/index.js&#x27;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"5-2、template-context-模板位置上下文\"><a href=\"#5-2、template-context-模板位置上下文\" class=\"headerlink\" title=\"5.2、template context 模板位置上下文\"></a>5.2、template context 模板位置上下文</h3><p>template context 模板位置上下文 ：就是你模板文件所在的文件夹位置，这个文件夹基本上是你读取并拷贝文件的地方。默认的template context是<code>./templates/</code>，你可以通过<code>generator.sourceRoot(&#39;new/template/path&#39;)</code>指定新的模板文件夹位置；与上面类似，可使用<code>generator.sourceRoot()</code>获取模板位置，使用<code>generator.templatePath(&#39;app/index.js&#39;)</code>拼接路径。示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">paths</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.sourceRoot();<br>    <span class=\"hljs-comment\">// returns &#x27;./templates&#x27;</span><br><br>    <span class=\"hljs-built_in\">this</span>.templatePath(<span class=\"hljs-string\">&#x27;index.js&#x27;</span>);<br>    <span class=\"hljs-comment\">// returns &#x27;~/templates/index.js&#x27;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"5-3、文件操作API\"><a href=\"#5-3、文件操作API\" class=\"headerlink\" title=\"5.3、文件操作API\"></a>5.3、文件操作API</h3><p>Yeoman把所有的文件方法都放在this.fs中了，它是<a href=\"https://github.com/sboudrias/mem-fs-editor\">mem-fs-editor</a>的一个示例对象，可自行查看API接口。<br><strong>示例：拷贝模板文件</strong><br>假如。、templates/index.html文件内容为：</p>\n<figure class=\"highlight vbscript-html\"><table><tr><td class=\"code\"><pre><code class=\"hljs vbscript-html\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span></span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span></span><span class=\"vbscript\">&lt;%= title %&gt;</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span></span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>我们使用copyTpl方法拷贝模板：（更多参看<a href=\"https://lodash.com/docs#template\">Lodash template syntax</a>）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">writing</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.fs.copyTpl(<br>      <span class=\"hljs-built_in\">this</span>.templatePath(<span class=\"hljs-string\">&#x27;index.html&#x27;</span>),<br>      <span class=\"hljs-built_in\">this</span>.destinationPath(<span class=\"hljs-string\">&#x27;public/index.html&#x27;</span>),<br>      &#123; <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;Templating with Yeoman&#x27;</span> &#125;<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>一旦生成器运行完成，我们就会获得public/index.html</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">Templating with Yeoman<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>Yeoman仍保留了旧的文件API，可参看 <a href=\"http://yeoman.github.io/generator/actions.html\">API documentation</a> 。旧的文件API总是假设文件来自template context，写文件总是在destination context中，所以它们不要求你传入文件路径信息，程序会自动处理</p>\n</blockquote>\n<p><strong>建议</strong>：尽可能使用新的<code>fs</code>API，它的使用起来比较清晰</p>\n<h2 id=\"6、储存用户设置\"><a href=\"#6、储存用户设置\" class=\"headerlink\" title=\"6、储存用户设置\"></a>6、储存用户设置</h2><p>常常需要存储用户的设置项并在子生成器中使用，比如用户使用什么编程语言（比如使用CoffeeScript？）等这些配置项都存储在.yo-rc.json中（使用 <a href=\"http://yeoman.github.io/generator/Storage.html\">Yeoman Storage API</a>.）,可以通过<code>generator.config</code>对象获取API方法。</p>\n<h3 id=\"6-1、常用方法\"><a href=\"#6-1、常用方法\" class=\"headerlink\" title=\"6.1、常用方法\"></a>6.1、常用方法</h3><ol>\n<li><p><code>generator.config.save()</code><br>保存配置项到文件.yo-rc.json文件中（若文件不存在将自动 创建），由于该文件决定工程的根目录，因而一个最佳实践就是：就算什么也没有也应当调用save方法。</p>\n<blockquote>\n<p>每次设置配置项都会自动调用save方法，因此你可以不用显示调用</p>\n</blockquote>\n</li>\n<li><p><code>generator.config.set(key,val)</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&quot;Name&quot;</span>: <span class=\"hljs-string\">&quot;用于存储的键&quot;</span>,<br><span class=\"hljs-string\">&quot;val&quot;</span> : <span class=\"hljs-string\">&quot;任何JSON类型的值（String，Number, Array, Object）&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>generator.config.get()</code><br>根据键获得配置项</p>\n</li>\n<li><p><code>generator.config.getAll()</code><br>获取可用的所有配置信息；主要返回值不是按引用返回的，所以要更改里面的配置项还是需要调用set方法。</p>\n</li>\n<li><p><code>generator.config.delete()</code><br>删除某个键值（及其值）</p>\n</li>\n<li><p><code>generator.config.defaults()</code><br>将对象作为默认的配置信息，采用不覆盖原则</p>\n</li>\n</ol>\n<h3 id=\"6-2、-yo-rc-json-文件结构\"><a href=\"#6-2、-yo-rc-json-文件结构\" class=\"headerlink\" title=\"6.2、.yo-rc.json 文件结构\"></a>6.2、.yo-rc.json 文件结构</h3><p>该文件可存储多个生成器的信息，每个生成器依据名字划分命名空间防止冲突，这也意味着每个生成器的配置项只能被子生成器读取到，不同生成器间的配置信息不能通过 Yeoman Storage API.访问。（使用命令行参数或者选项在不同构造器间传递参数。</p>\n<p>文件样本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-string\">&quot;generator-backbone&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;requirejs&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-string\">&quot;coffee&quot;</span>: <span class=\"hljs-literal\">true</span><br>  &#125;,<br>  <span class=\"hljs-string\">&quot;generator-gruntfile&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;compass&quot;</span>: <span class=\"hljs-literal\">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"http://yeoman.io/authoring/\">WRITING YOUR OWN YEOMAN GENERATOR</a></li>\n<li><a href=\"http://www.html-js.com/article/1732\">学习Bower – 前端开发包管理工具</a><blockquote>\n<p>   原文的2个链接失效了，不放上来了</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"整理文档\"><a href=\"#整理文档\" class=\"headerlink\" title=\"整理文档\"></a>整理文档</h2><ol>\n<li><a href=\"http://www.jscon.co/coding/frontend/yeoman_generator.html\">自定义Yeoman生成器 —— JSCON-简时空</a></li>\n</ol>\n","more":"<h2 id=\"1-Getting-Started\"><a href=\"#1-Getting-Started\" class=\"headerlink\" title=\"1 Getting Started\"></a>1 Getting Started</h2><h3 id=\"1-1、设置Node模块\"><a href=\"#1-1、设置Node模块\" class=\"headerlink\" title=\"1.1、设置Node模块\"></a>1.1、设置Node模块</h3><p>Yeoman提供了generator-generator方便快速编写自己的生成器。</p>\n<blockquote>\n<p>安装: npm install -g generator-generator</p>\n</blockquote>\n<blockquote>\n<p>运行: yo generator</p>\n</blockquote>\n<ul>\n<li>创建一个名为generator-name的文件夹（name为你的生成器名）;【important】</li>\n<li>创建package.json文件，这是NodeJS模块的“信息图”，可以手动或者使用命令npm init生成</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;generator-name&quot;</span>,<br>  <span class=\"hljs-string\">&quot;version&quot;</span>: <span class=\"hljs-string\">&quot;0.1.0&quot;</span>,<br>  <span class=\"hljs-string\">&quot;description&quot;</span>: <span class=\"hljs-string\">&quot;&quot;</span>,<br>  <span class=\"hljs-string\">&quot;keywords&quot;</span>: [<span class=\"hljs-string\">&quot;yeoman-generator&quot;</span>],<br>  <span class=\"hljs-string\">&quot;dependencies&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;yeoman-generator&quot;</span>: <span class=\"hljs-string\">&quot;^0.17.3&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>name属性必须要有generator-前缀；keywords属性必须包含yeoman-generator，务必确保是最新的，可运行命令npm install –save yeoman-generator完成更新/安装</p>\n</blockquote>\n<h3 id=\"1-2、文件树结构\"><a href=\"#1-2、文件树结构\" class=\"headerlink\" title=\"1.2、文件树结构\"></a>1.2、文件树结构</h3><ol>\n<li>当调用yo name命令时，默认调用的是app生成器，对于的逻辑放置在app/文件夹下</li>\n<li>当调用yo name:subcommand命令时，必须要有对于的subcommand/文件夹</li>\n</ol>\n<p>如果文件结构如下，则该生成器暴露yo name和yo name:router两个命令</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">├───package.json<br>├───app/<br>│   └───index.js<br>└───router/<br>    └───index.js<br></code></pre></td></tr></table></figure>\n\n<p>如果你不想把所有代码都放在根目录下，Yeoman提供了另外的一种方式：可以放在generators/目录下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">├───package.json<br>└───generators/<br>    ├───app/<br>    │   └───index.js<br>    └───router/<br>        └───index.js<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-3、继承generator\"><a href=\"#1-3、继承generator\" class=\"headerlink\" title=\"1.3、继承generator\"></a>1.3、继承generator</h3><p>结构写好了，需要开始写实际的逻辑代码。Yeoman提供了基础生成器供你继承，这些基础生成器提供了很多方便的方法供你调用。基本写法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> generators = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;yeoman-generator&#x27;</span>);<br><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend();<br></code></pre></td></tr></table></figure>\n\n<p>如果你的生成器需要name参数（比如yo name:router foo中的foo），想将它赋给this.name的话：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> generators = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;yeoman-generator&#x27;</span>);<br><span class=\"hljs-built_in\">module</span>.exports = generators.NamedBase.extend();<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>上面两种方式都能用于创建app生成器或者子生成器，Base多用于app生成器，NamedBase多用于需要指定文件名的子生成器</p>\n</blockquote>\n<h3 id=\"1-4、重写构造函数\"><a href=\"#1-4、重写构造函数\" class=\"headerlink\" title=\"1.4、重写构造函数\"></a>1.4、重写构造函数</h3><p>有些方法只能在constructor方法中调用，常用于状态控制；可以传入构造函数重写默认的构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-comment\">// The name `constructor` is important here</span><br>  <span class=\"hljs-attr\">constructor</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-comment\">// Calling the super constructor is important so our generator is correctly set up</span><br>    generators.Base.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br><br>    <span class=\"hljs-comment\">// Next, add your custom code</span><br>    <span class=\"hljs-built_in\">this</span>.option(<span class=\"hljs-string\">&#x27;coffee&#x27;</span>); <span class=\"hljs-comment\">// This method adds support for a `--coffee` flag</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"1-5、添加方法\"><a href=\"#1-5、添加方法\" class=\"headerlink\" title=\"1.5、添加方法\"></a>1.5、添加方法</h3><p>一般给原型添加的方法是按顺序执行的，不过后面我们会看到一些特殊的方法会触发不同的执行顺序：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">method1</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;method 1 just ran&#x27;</span>);<br>  &#125;,<br>  <span class=\"hljs-attr\">method2</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;method 2 just ran&#x27;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"1-6、运行生成器\"><a href=\"#1-6、运行生成器\" class=\"headerlink\" title=\"1.6、运行生成器\"></a>1.6、运行生成器</h3><p>到了这一步，你已经拥有一个可以运行的生成器了。下一步就是检验生成器是否按自己的逻辑运行。由于是在本地开发生成器，在全局npm模块中并不存在，需要手动链接。进入generator-name/文件夹，运行：</p>\n<figure class=\"highlight coffeescript\"><table><tr><td class=\"code\"><pre><code class=\"hljs coffeescript\"><span class=\"hljs-built_in\">npm</span> link<br></code></pre></td></tr></table></figure>\n<p>这将自动安装工程依赖包，同时将本地文件链接进全局模块；运行完毕之后，你就可以调用yo name并看到之前定义的console.log信息。</p>\n<p>至此，恭喜你完成了简单的生成器！</p>\n<h3 id=\"1-7、找到工程根目录\"><a href=\"#1-7、找到工程根目录\" class=\"headerlink\" title=\"1.7、找到工程根目录\"></a>1.7、找到工程根目录</h3><p>当运行一个生成器，Yeoman将计算当前的文件目录信息。最为关键的是，Yeoman将.yo-rc.json所在的目录作为工程的根目录，之后Yeoman将当前文件目录跳转到根目录下运行请求的生成器。这个.yo-rc.json文件是由Storage模块创建的，在生成器内部调用this.config.save()方法就会创建它。所以，如果你发现你的生成器不是在你当前工作目录下运行，请确保。yo-rc.json不存在你目录的其他层级中</p>\n<h2 id=\"2、运行上下文\"><a href=\"#2、运行上下文\" class=\"headerlink\" title=\"2、运行上下文\"></a>2、运行上下文</h2><h3 id=\"2-1、静态方法都是Action\"><a href=\"#2-1、静态方法都是Action\" class=\"headerlink\" title=\"2.1、静态方法都是Action\"></a>2.1、静态方法都是Action</h3><p>如果一个函数直接作为生成器的原型（prototype）的属性，则会当做action自动（按顺序）执行。如何声明不会自动执行的辅助函数以及私有函数呢？有三种方法：</p>\n<ol>\n<li>给方法前面添加前缀（例如：_method）</li>\n<li>使用实例函数声明（this.mehtod）<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">init</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.helperMethod = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;won\\&#x27;t be called automatically&#x27;</span>);<br>    &#125;;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li>\n<li>继承自父类生成器<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">var</span> MyBase = generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">helper</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;won\\&#x27;t be called automatically&#x27;</span>);<br>  &#125;<br>&#125;);<br><br><span class=\"hljs-built_in\">module</span>.exports = MyBase.extend(&#123;<br>  <span class=\"hljs-attr\">exec</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.helper();<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"2-2、运行顺序\"><a href=\"#2-2、运行顺序\" class=\"headerlink\" title=\"2.2、运行顺序\"></a>2.2、运行顺序</h3>Yeoman是按照优先级顺序依次执行所定义的方法。当你定义的函数名字是Yeoman定义的优先级函数名时，会自动将该函数列入到所在优先级队列中，否则就会列入到default优先层级队列中。</li>\n</ol>\n<p>依次执行的方法名称为：</p>\n<ol>\n<li><strong>initializing</strong> - 你的初始化方法（检测当前目录状态，获取配置等）</li>\n<li><strong>prompting</strong> – 给用户展示选项提示（调用this.prompt()）</li>\n<li><strong>configuring</strong> – 保存用户配置项，同时配置工程（创建.editorconfig文件或者其他metadata文件）</li>\n<li><strong>default</strong></li>\n<li><strong>writing</strong> – 用于生成和生成器相关的文件（比如routes,controllers等）</li>\n<li><strong>conflicts</strong> – 用于处理冲突异常（内部使用）</li>\n<li><strong>install</strong> – 用于安装相关库 (npm, bower)</li>\n<li><strong>end</strong> – 最后调用，常用于清理、道别等</li>\n</ol>\n<h2 id=\"3、UI\"><a href=\"#3、UI\" class=\"headerlink\" title=\"3、UI\"></a>3、UI</h2><p>Yeoman默认是跑在终端的，但不限于终端。因此记住，不要使用console.log()或者process.stdout.write()向用户反馈信息，应当使用generator.log方法。</p>\n<h3 id=\"3-1、提示框\"><a href=\"#3-1、提示框\" class=\"headerlink\" title=\"3.1、提示框\"></a>3.1、提示框</h3><p>Yeoman中最为主要的UI交互就是提示框，由Inquirer.js组件提供。使用下列方式调用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">prompting</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> done = <span class=\"hljs-built_in\">this</span>.async();<br>    <span class=\"hljs-built_in\">this</span>.prompt(&#123;<br>      <span class=\"hljs-attr\">type</span>    : <span class=\"hljs-string\">&#x27;input&#x27;</span>,<br>      <span class=\"hljs-attr\">name</span>    : <span class=\"hljs-string\">&#x27;name&#x27;</span>,<br>      <span class=\"hljs-attr\">message</span> : <span class=\"hljs-string\">&#x27;Your project name&#x27;</span>,<br>      <span class=\"hljs-attr\">default</span> : <span class=\"hljs-built_in\">this</span>.appname <span class=\"hljs-comment\">// Default to current folder name</span><br>    &#125;, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">answers</span>) </span>&#123;<br>      <span class=\"hljs-built_in\">this</span>.log(answers.name);<br>      done();<br>    &#125;.bind(<span class=\"hljs-built_in\">this</span>));<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>这里我们使用promoting的优先层级 。由于咨询用户是一个异步的过程，会卡住命令逻辑的运行，所以需要调用yo的异步方法：<code>var cb = this.async();</code></p>\n</blockquote>\n<h3 id=\"3-2、记住用户偏好\"><a href=\"#3-2、记住用户偏好\" class=\"headerlink\" title=\"3.2、记住用户偏好\"></a>3.2、记住用户偏好</h3><p>当用户运行你的生成器时，很多时候会输入相同的答案；Yeoman扩展了Inquirer.js的API，额外增加了store的属性表示用户可以将之前填写过的答案作为后续的默认答案：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">this</span>.prompt(&#123;<br>  <span class=\"hljs-attr\">type</span>    : <span class=\"hljs-string\">&#x27;input&#x27;</span>,<br>  <span class=\"hljs-attr\">name</span>    : <span class=\"hljs-string\">&#x27;username&#x27;</span>,<br>  <span class=\"hljs-attr\">message</span> : <span class=\"hljs-string\">&#x27;What\\&#x27;s your Github username&#x27;</span>,<br>  <span class=\"hljs-attr\">store</span>   : <span class=\"hljs-literal\">true</span><br>&#125;, callback);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>提供默认答案时，程序会强制用户输入</p>\n</blockquote>\n<h3 id=\"3-3、命令行参数\"><a href=\"#3-3、命令行参数\" class=\"headerlink\" title=\"3.3、命令行参数\"></a>3.3、命令行参数</h3><p>可以直接像在命令中传入参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">yo webapp my-project<br></code></pre></td></tr></table></figure>\n<p>在这里，my-project作为第一个参数。为了提示系统我们期望用户传入参数，需要调用generator.argument()方法，该方法接受name作为参数，以及额外的限制条件。</p>\n<blockquote>\n<p> 该argument方法必须在构造器中调用。这些条件是（key/value型）：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;desc&#x27;</span>： <span class=\"hljs-comment\">//Description for the argument</span><br><span class=\"hljs-string\">&#x27;required&#x27;</span>： <span class=\"hljs-comment\">// Boolean whether it is required</span><br><span class=\"hljs-string\">&#x27;optional&#x27;</span>： <span class=\"hljs-comment\">//Boolean whether it is optional</span><br><span class=\"hljs-string\">&#x27;type&#x27;</span>： <span class=\"hljs-comment\">// String, Number, Array, or Object</span><br><span class=\"hljs-string\">&#x27;defaults&#x27;</span>： <span class=\"hljs-comment\">//Default value for this argument</span><br><span class=\"hljs-string\">&#x27;banner&#x27;</span>:  <span class=\"hljs-comment\">//String to show on usage notes (this one is provided by default)</span><br></code></pre></td></tr></table></figure>\n<p>示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-comment\">// note: arguments and options should be defined in the constructor.</span><br>  <span class=\"hljs-attr\">constructor</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    generators.Base.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br><br>    <span class=\"hljs-comment\">// This makes `appname` a required argument.</span><br>    <span class=\"hljs-built_in\">this</span>.argument(<span class=\"hljs-string\">&#x27;appname&#x27;</span>, &#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-built_in\">String</span>, <span class=\"hljs-attr\">required</span>: <span class=\"hljs-literal\">true</span> &#125;);<br>    <span class=\"hljs-comment\">// And you can then access it later on this way; e.g. CamelCased</span><br>    <span class=\"hljs-built_in\">this</span>.appname = <span class=\"hljs-built_in\">this</span>._.camelize(<span class=\"hljs-built_in\">this</span>.appname);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-4、选项\"><a href=\"#3-4、选项\" class=\"headerlink\" title=\"3.4、选项\"></a>3.4、选项</h3><p>选项看上去像参数，不过它前面多了两短横杠（flags）：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">yo webapp --coffee<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>使用generator.option()方法获取选项值，该方法也有可选的限制属性（key/value型）：</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&#x27;desc&#x27;</span>： <span class=\"hljs-comment\">// Description for the option</span><br><span class=\"hljs-string\">&#x27;type&#x27;</span> ：<span class=\"hljs-comment\">// Either Boolean, String or Number</span><br><span class=\"hljs-string\">&#x27;defaults&#x27;</span>： <span class=\"hljs-comment\">// Default value</span><br><span class=\"hljs-string\">&#x27;hide&#x27;</span>： <span class=\"hljs-comment\">//Boolean whether to hide from help</span><br></code></pre></td></tr></table></figure>\n<p>举例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-built_in\">module</span>.exports = generators.Base.extend(&#123;<br>  <span class=\"hljs-comment\">// note: arguments and options should be defined in the constructor.</span><br>  <span class=\"hljs-attr\">constructor</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    generators.Base.apply(<span class=\"hljs-built_in\">this</span>, <span class=\"hljs-built_in\">arguments</span>);<br><br>    <span class=\"hljs-comment\">// This method adds support for a `--coffee` flag</span><br>    <span class=\"hljs-built_in\">this</span>.option(<span class=\"hljs-string\">&#x27;coffee&#x27;</span>);<br>    <span class=\"hljs-comment\">// And you can then access it later on this way; e.g.</span><br>    <span class=\"hljs-built_in\">this</span>.scriptSuffix = (<span class=\"hljs-built_in\">this</span>.options.coffee ? <span class=\"hljs-string\">&quot;.coffee&quot;</span>: <span class=\"hljs-string\">&quot;.js&quot;</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"4、处理依赖\"><a href=\"#4、处理依赖\" class=\"headerlink\" title=\"4、处理依赖\"></a>4、处理依赖</h2><p>在运行生成器时，经常会伴随着npm和bower命令去安装依赖文件，Yeoman已经将这些功能抽离出来方便用户使用</p>\n<h3 id=\"4-1、npm\"><a href=\"#4-1、npm\" class=\"headerlink\" title=\"4.1、npm\"></a>4.1、npm</h3><p>使用generator.npmInstall()运行npm安装命令，无论你调用多少次，Yeoman会确保该命令只执行一次</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">installingLodash</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-keyword\">var</span> done = <span class=\"hljs-built_in\">this</span>.async();<br>    <span class=\"hljs-built_in\">this</span>.npmInstall([<span class=\"hljs-string\">&#x27;lodash&#x27;</span>], &#123; <span class=\"hljs-string\">&#x27;saveDev&#x27;</span>: <span class=\"hljs-literal\">true</span> &#125;, done);<br>  &#125;<br>&#125;):<br></code></pre></td></tr></table></figure>\n<p>上面的代码等价于命令行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">npm install lodash --save-dev<br></code></pre></td></tr></table></figure>\n<h3 id=\"4-2、bower\"><a href=\"#4-2、bower\" class=\"headerlink\" title=\"4.2、bower\"></a>4.2、bower</h3><p>使用generator.bowerInstall()运行bower安装命令，无论你调用多少次，Yeoman会确保该命令只执行一次</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">end</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.spawnCommand(<span class=\"hljs-string\">&#x27;composer&#x27;</span>, [<span class=\"hljs-string\">&#x27;install&#x27;</span>]);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>记得在end队列中调用spawnCommand命令,否则用户没有耐心等那么久的。</p>\n</blockquote>\n<h2 id=\"5、文件系统\"><a href=\"#5、文件系统\" class=\"headerlink\" title=\"5、文件系统\"></a>5、文件系统</h2><p>方便文件流的输入输出，Yeoman使用两种位置环境： <strong>destination context</strong>  和 <strong>template context</strong></p>\n<h3 id=\"5-1、destination-contex-目标位置上下文\"><a href=\"#5-1、destination-contex-目标位置上下文\" class=\"headerlink\" title=\"5.1、destination contex 目标位置上下文\"></a>5.1、destination contex 目标位置上下文</h3><p>destination context 目标位置上下文，这里的“目标”是指你想架构应用的位置。这个位置要么是当前文件夹，要么就是文件.yo-rc.json所在的父文件夹位置；</p>\n<blockquote>\n<p>该.yo-rc.json文件确保所有的终端用户都以同样的方式方法生成器所在的子文件（夹）</p>\n</blockquote>\n<p>使用<code>generator.destinationRoot()</code>获取目标位置上下文；也可以手动传参重新设置，当然没有人愿意那么做的；用<code>generator.destinationPath(&#39;sub/path&#39;)</code>拼接所需要的路径字符串。示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// Given destination root is ~/projects</span><br>generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">paths</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.destinationRoot();<br>    <span class=\"hljs-comment\">// returns &#x27;~/projects&#x27;</span><br><br>    <span class=\"hljs-built_in\">this</span>.destinationPath(<span class=\"hljs-string\">&#x27;index.js&#x27;</span>);<br>    <span class=\"hljs-comment\">// returns &#x27;~/projects/index.js&#x27;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"5-2、template-context-模板位置上下文\"><a href=\"#5-2、template-context-模板位置上下文\" class=\"headerlink\" title=\"5.2、template context 模板位置上下文\"></a>5.2、template context 模板位置上下文</h3><p>template context 模板位置上下文 ：就是你模板文件所在的文件夹位置，这个文件夹基本上是你读取并拷贝文件的地方。默认的template context是<code>./templates/</code>，你可以通过<code>generator.sourceRoot(&#39;new/template/path&#39;)</code>指定新的模板文件夹位置；与上面类似，可使用<code>generator.sourceRoot()</code>获取模板位置，使用<code>generator.templatePath(&#39;app/index.js&#39;)</code>拼接路径。示例：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">paths</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.sourceRoot();<br>    <span class=\"hljs-comment\">// returns &#x27;./templates&#x27;</span><br><br>    <span class=\"hljs-built_in\">this</span>.templatePath(<span class=\"hljs-string\">&#x27;index.js&#x27;</span>);<br>    <span class=\"hljs-comment\">// returns &#x27;~/templates/index.js&#x27;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<h3 id=\"5-3、文件操作API\"><a href=\"#5-3、文件操作API\" class=\"headerlink\" title=\"5.3、文件操作API\"></a>5.3、文件操作API</h3><p>Yeoman把所有的文件方法都放在this.fs中了，它是<a href=\"https://github.com/sboudrias/mem-fs-editor\">mem-fs-editor</a>的一个示例对象，可自行查看API接口。<br><strong>示例：拷贝模板文件</strong><br>假如。、templates/index.html文件内容为：</p>\n<figure class=\"highlight vbscript-html\"><table><tr><td class=\"code\"><pre><code class=\"hljs vbscript-html\"><span class=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span></span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span></span><br><span class=\"xml\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span></span><span class=\"vbscript\">&lt;%= title %&gt;</span><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span></span><br><span class=\"xml\">  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span></span><br><span class=\"xml\"><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>我们使用copyTpl方法拷贝模板：（更多参看<a href=\"https://lodash.com/docs#template\">Lodash template syntax</a>）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">generators.Base.extend(&#123;<br>  <span class=\"hljs-attr\">writing</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>    <span class=\"hljs-built_in\">this</span>.fs.copyTpl(<br>      <span class=\"hljs-built_in\">this</span>.templatePath(<span class=\"hljs-string\">&#x27;index.html&#x27;</span>),<br>      <span class=\"hljs-built_in\">this</span>.destinationPath(<span class=\"hljs-string\">&#x27;public/index.html&#x27;</span>),<br>      &#123; <span class=\"hljs-attr\">title</span>: <span class=\"hljs-string\">&#x27;Templating with Yeoman&#x27;</span> &#125;<br>    );<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>一旦生成器运行完成，我们就会获得public/index.html</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><code class=\"hljs bash\">Templating with Yeoman<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>Yeoman仍保留了旧的文件API，可参看 <a href=\"http://yeoman.github.io/generator/actions.html\">API documentation</a> 。旧的文件API总是假设文件来自template context，写文件总是在destination context中，所以它们不要求你传入文件路径信息，程序会自动处理</p>\n</blockquote>\n<p><strong>建议</strong>：尽可能使用新的<code>fs</code>API，它的使用起来比较清晰</p>\n<h2 id=\"6、储存用户设置\"><a href=\"#6、储存用户设置\" class=\"headerlink\" title=\"6、储存用户设置\"></a>6、储存用户设置</h2><p>常常需要存储用户的设置项并在子生成器中使用，比如用户使用什么编程语言（比如使用CoffeeScript？）等这些配置项都存储在.yo-rc.json中（使用 <a href=\"http://yeoman.github.io/generator/Storage.html\">Yeoman Storage API</a>.）,可以通过<code>generator.config</code>对象获取API方法。</p>\n<h3 id=\"6-1、常用方法\"><a href=\"#6-1、常用方法\" class=\"headerlink\" title=\"6.1、常用方法\"></a>6.1、常用方法</h3><ol>\n<li><p><code>generator.config.save()</code><br>保存配置项到文件.yo-rc.json文件中（若文件不存在将自动 创建），由于该文件决定工程的根目录，因而一个最佳实践就是：就算什么也没有也应当调用save方法。</p>\n<blockquote>\n<p>每次设置配置项都会自动调用save方法，因此你可以不用显示调用</p>\n</blockquote>\n</li>\n<li><p><code>generator.config.set(key,val)</code></p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-string\">&quot;Name&quot;</span>: <span class=\"hljs-string\">&quot;用于存储的键&quot;</span>,<br><span class=\"hljs-string\">&quot;val&quot;</span> : <span class=\"hljs-string\">&quot;任何JSON类型的值（String，Number, Array, Object）&quot;</span><br></code></pre></td></tr></table></figure></li>\n<li><p><code>generator.config.get()</code><br>根据键获得配置项</p>\n</li>\n<li><p><code>generator.config.getAll()</code><br>获取可用的所有配置信息；主要返回值不是按引用返回的，所以要更改里面的配置项还是需要调用set方法。</p>\n</li>\n<li><p><code>generator.config.delete()</code><br>删除某个键值（及其值）</p>\n</li>\n<li><p><code>generator.config.defaults()</code><br>将对象作为默认的配置信息，采用不覆盖原则</p>\n</li>\n</ol>\n<h3 id=\"6-2、-yo-rc-json-文件结构\"><a href=\"#6-2、-yo-rc-json-文件结构\" class=\"headerlink\" title=\"6.2、.yo-rc.json 文件结构\"></a>6.2、.yo-rc.json 文件结构</h3><p>该文件可存储多个生成器的信息，每个生成器依据名字划分命名空间防止冲突，这也意味着每个生成器的配置项只能被子生成器读取到，不同生成器间的配置信息不能通过 Yeoman Storage API.访问。（使用命令行参数或者选项在不同构造器间传递参数。</p>\n<p>文件样本：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><code class=\"hljs javascript\">&#123;<br>  <span class=\"hljs-string\">&quot;generator-backbone&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;requirejs&quot;</span>: <span class=\"hljs-literal\">true</span>,<br>    <span class=\"hljs-string\">&quot;coffee&quot;</span>: <span class=\"hljs-literal\">true</span><br>  &#125;,<br>  <span class=\"hljs-string\">&quot;generator-gruntfile&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;compass&quot;</span>: <span class=\"hljs-literal\">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h2><ol>\n<li><a href=\"http://yeoman.io/authoring/\">WRITING YOUR OWN YEOMAN GENERATOR</a></li>\n<li><a href=\"http://www.html-js.com/article/1732\">学习Bower – 前端开发包管理工具</a><blockquote>\n<p>   原文的2个链接失效了，不放上来了</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"整理文档\"><a href=\"#整理文档\" class=\"headerlink\" title=\"整理文档\"></a>整理文档</h2><ol>\n<li><a href=\"http://www.jscon.co/coding/frontend/yeoman_generator.html\">自定义Yeoman生成器 —— JSCON-简时空</a></li>\n</ol>","categories":[{"name":"node","path":"api/categories/node.json"}],"tags":[{"name":"F2E","path":"api/tags/F2E.json"},{"name":"node","path":"api/tags/node.json"},{"name":"f2e","path":"api/tags/f2e.json"},{"name":"yeoman","path":"api/tags/yeoman.json"},{"name":"kmapp","path":"api/tags/kmapp.json"},{"name":"generator","path":"api/tags/generator.json"}]}